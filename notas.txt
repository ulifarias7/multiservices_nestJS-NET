COSAS QUE FALTAN :

# dejar las bases de datos iguales con minusculas 
# acomodar codigo en los servicios con modelos , un tipo de respuesta generico y agregarlos
# agregarles mas buenas practicas 
# documentar los servicios


//////////////////////////KEYCLOACKK
‚úÖ Arquitectura correcta cuando Keycloak es tu Identity Provider
1. Auth-Service ‚Üí crea usuarios SOLO en Keycloak

Keycloak es la fuente de verdad en cuanto a identidad.
Los usuarios se crean, habilitan, deshabilitan, resetean contrase√±a SOLO en Keycloak.

Tu Auth-Service deber√≠a tener endpoints como:

POST /auth/register
POST /auth/login
POST /auth/refresh
POST /auth/logout
POST /auth/verify-email
POST /auth/forgot-password

Y cada uno llama a la API Admin de Keycloak.

‚úÖ 2. Cuando el usuario se crea en Keycloak ‚Üí se replica al User-Service

Ten√©s 2 opciones:

üî• Opci√≥n A (la mejor): Webhook/Evento desde Auth-Service

POST /auth/register recibe la info del usuario.

Auth-Service le pega a Keycloak ‚Üí usuario creado.

Auth-Service llama a User-Service:

POST /user
{
   "keycloakId": "uuid-de-keycloak",
   "email": "...",
   "firstname": "...",
   "lastname": "...",
   ...
}


User-Service guarda solo los datos que Keycloak NO maneja.

Ventajas:
Vos control√°s la transacci√≥n.
Ten√©s 0 acoplamiento entre servicios.
No depend√©s de plugins de Keycloak.

auth-services-dev = reino 
auth.service@yopmail.com = username
admin = contrase√±a
http://localhost:8082/realms/auth-service/account  (link para usuario)


Keycloak:
estoy con la implementacion de keycloack y estoy viendo una data piola que cuando generas el reino para tu app y le 
creas un cliente para la autenticacion, tokenizacion etc podes poner tambein el tipo de cliente que queres que sea .

üîµ Client Type: Public

-No tiene secret client
-Para frontends (Angular, React, mobile)

üîµ Client Type: Confidential

-Tiene secret
-Solo servidores backend

üîµ Client Type: Bearer-Only

-NO pide tokens
-Solo valida tokens enviados por un API Gateway / backend
-Nunca inicia sesi√≥n

tambien me paso con los flujos de trabajo por lo general siempre usamos el flujo de trabajo estandar pero creo que vi que existen otros tipos 

Flujo	Para qu√© sirve
Standard Flow = Login normal (redirect a Keycloak)
Direct Access Grants = Login con usuario/contrase√±a desde Postman (sin redirect)
Service Accounts = Autenticaci√≥n m√°quina a m√°quina


osea que keycloack trabaja asi 
1- S√≠, es en tu realm auth-services-dev
2- El ‚Äúcliente‚Äù es la app que quer√©s registrar
3- El ID del cliente es lo que tu backend/frontend va a usar para pedir tokens
4- OpenID Connect es el protocolo de autenticaci√≥n
5- Standard Flow debe estar activado para apps con login
6- Login Settings controla redirect URIs y CORS

tambien lo  que se puede hacer es optimizar la imagen de keyclaock que estes usando en tu contenedor 
podes generar un archivo que se llame  Containerfile (utiliza la misma sintaxis que un dockerfile)

Archivo que recomienda la docu : 

FROM quay.io/keycloak/keycloak:latest AS builder

# Enable health and metrics support
ENV KC_HEALTH_ENABLED=true
ENV KC_METRICS_ENABLED=true

# Configure a database vendor
ENV KC_DB=postgres

WORKDIR /opt/keycloak
# for demonstration purposes only, please make sure to use proper certificates in production instead
RUN keytool -genkeypair -storepass password -storetype PKCS12 -keyalg RSA -keysize 2048 -dname "CN=server" -alias server -ext "SAN:c=DNS:localhost,IP:127.0.0.1" -keystore conf/server.keystore
RUN /opt/keycloak/bin/kc.sh build

FROM quay.io/keycloak/keycloak:latest
COPY --from=builder /opt/keycloak/ /opt/keycloak/

# change these values to point to a running postgres instance
ENV KC_DB=postgres
ENV KC_DB_URL=<DBURL>
ENV KC_DB_USERNAME=<DBUSERNAME>
ENV KC_DB_PASSWORD=<DBPASSWORD>
ENV KC_HOSTNAME=localhost
ENTRYPOINT ["/opt/keycloak/bin/kc.sh"]

puedes tener script personalizados para el trabajo especifico que necesites , por ejemplo la importacion de un reino al iniciar el contenedor


el funcionamiento correcto de keycloack es :

Con Keycloak bien implementado, tu backend NO deber√≠a:

‚ùå manejar contrase√±as
‚ùå crear usuarios manuales desde tu base propia
‚ùå emitir JWTs
‚ùå validar credenciales (email/contrase√±a)
‚ùå almacenar usuarios en tu base

Todo eso lo hace Keycloak.

Tu API solo debe:

‚úîÔ∏è Validar el token (middleware JWT en .NET)
‚úîÔ∏è Aplicar roles/claims del token
‚úîÔ∏è Usar el userId que viene en el token

Endpoint que deberiamos usar y desde donde generar la solicitud :
POST /realms/{realm}/protocol/openid-connect/token (login = frontend)
POST /realms/{realm}/protocol/openid-connect/token (refresh_token = frontend)
(grant_type=refresh_token)

AdminAPI:
GET  /admin/realms/{realm}/users
POST /admin/realms/{realm}/users
GET  /admin/realms/{realm}/users/{id}
PUT  /admin/realms/{realm}/users/{id}
PUT cambiar la contrase√±a
DELETE /admin/realms/{realm}/users/{id}

login UI
http://localhost:8082/realms/{realm}/protocol/openid-connect/auth

validar certificados
/realms/{realm}/protocol/openid-connect/certs

recordatorio de lo unico que deberia hacer keycloack en la app:
La API solo usa Keycloak para administrar usuarios

Cuando corresponde(API):
-Crear usuario
-Buscar usuario
-Cambiar email
-Resetear contrase√±a
-Deshabilitar usuario
Eso es usando el Admin REST API, pero con un token de administrador, no de usuario.

cuando corresponde(frontend):
-Login
-Logout
-Refresh token
-Obtener token
-Actualizar perfil del usuario autenticado
-Cambiar contrase√±a desde UI

que es keycloack? 
es un identity provider y authorization server esto quiere decir que manneja :
-Maneja autenticaci√≥n (login, logout, sesiones, tokens)
-Maneja autorizaci√≥n (roles, permisos)
-Maneja identidad de usuarios (perfiles, emails, contrase√±as)
-Emite tokens JWT para que tus APIs y frontends sepan qui√©n es el usuario.

es el provedor de login 

por que keycloack trae  un usuario admin por defecto ?
para administrar el servidor de keyclaock pero no la configuracion de tu app
-crea reino y borra 
-ver logs
-cambiar configuracion globales 
-crear usuario dentro de cualquier realm 

el mismo usario sabe de cuando creas las variables de entorno al crear el contenedor .

Que es un realm de keycloack ?
es un entorno de configiracion que el usuario admin habilita para poder configurar 
los requisistos que necesites para tu aplicacion .

sirve para :
Los usuarios de esa aplicaci√≥n
Los roles
Los clients (apps que se autentican con Keycloak)
Pol√≠ticas
Flujos de login
Configuraci√≥n del token
Proveedores de identidad externos

es necesario creartu reino para no mezclar tus usuarios con el admin .

Que es un cliente de keycloack?
un cliente es una aplicaicion que usa keycloack para autenticarse .. eciste 3 tipos de authenticacion 
publicas = frontend
cli = admin-cli (VIENE POR DEFECTO )
confidencial = api (valida token)

el admin-cli = se usa para la administracion interna 

se puede trabajar de dos formas para poder pegarle desde tu app a keycloack 
1-usar el admin-cli (tiene los permisos administrativos)
2-usar un cliente creado por vos (en el reino master) y otorgarle permisos de admin , ese rol le va a dar al reino el control administrativo
Le asign√°s:
-realm-management / manage-users
-realm-management / realm-admin

osea en resumen es asi 
1-el usuario admin que viene por defecto es para adminitrar todo keyclaock.
2-el reino master es un "panel de control" global que administre todo Keycloak.crea reinos , crea usuario admin y clientes globales.
3-el reino que vos cree es tu app ,es donde va a estar todo lo de tu app (usuarios,empresas etc).
4-el cliente que vos cree es para la authenticacion de tu app por eso esta dentro de tu reino (la autenticacion puede ser publica, confidencial o cli)


reino de mi app - auth-service
usuario de mi reino - myuserkeycloack@yopmial.com - myuser123


///////////////////////////////////////////////
Audit services :
app donde se va a consumir los eventos de cada microservicio y generar logger a nivel datos en una base de datos para llevar el control
de las acciones (que paso , quien lo creo , cuando y que datos (id).)

Tabla de ejemplo para guiarme:
CREATE TABLE audit_events (
    id                  UUID PRIMARY KEY,
    
    event_name           TEXT NOT NULL,          -- created.document, send.email (nombre del evento)
    routing_key          TEXT NOT NULL,          -- created.document (nombre de la cola)
    exchange             TEXT NOT NULL,          -- app.events   (de donde viene )

    source_service       TEXT NOT NULL,          -- document-service, auth-service
    source_host          TEXT NULL,              -- opcional (pod / container)

    payload              JSONB NOT NULL,         -- mensaje completo
    headers              JSONB NULL,             -- headers Rabbit / tracing

    correlation_id       TEXT NULL,              -- para tracing distribuido
    causation_id         TEXT NULL,              -- evento padre
    message_id           TEXT NOT NULL,          -- Rabbit messageId

    occurred_at          TIMESTAMPTZ NOT NULL,   -- cuando ocurri√≥ el evento
    received_at          TIMESTAMPTZ NOT NULL,   -- cuando audit lo guard√≥

    created_at           TIMESTAMPTZ NOT NULL DEFAULT now()
); 


(asi lo hice)
	ALTER TABLE public."Audits"
ADD COLUMN IF NOT EXISTS "EventName"     TEXT        NOT NULL,
ADD COLUMN IF NOT EXISTS "RoutingKey"    TEXT        NOT NULL,
ADD COLUMN IF NOT EXISTS "Exchange"      TEXT        NOT NULL,
ADD COLUMN IF NOT EXISTS "SourceService" TEXT        NOT NULL,
ADD COLUMN IF NOT EXISTS "SourceHost"    TEXT,
ADD COLUMN IF NOT EXISTS "Payload"       JSONB       NOT NULL,
ADD COLUMN IF NOT EXISTS "Headers"       JSONB,
ADD COLUMN IF NOT EXISTS "CorrelationId" TEXT,
ADD COLUMN IF NOT EXISTS "CausationId"   TEXT,
ADD COLUMN IF NOT EXISTS "MessageId"     TEXT        NOT NULL,
ADD COLUMN IF NOT EXISTS "OccurredAt"    TIMESTAMPTZ NOT NULL,
ADD COLUMN IF NOT EXISTS "ReceivedAt"    TIMESTAMPTZ NOT NULL,
ADD COLUMN IF NOT EXISTS "CreatedAt"     TIMESTAMPTZ NOT NULL DEFAULT now();

-----------------------------------------------------
para ejecutar la app de netsjs (user-service)

para que tome el env.local..

# Si EXISTE .env.local ‚Üí Usa .env.local
npm run dev
npm run dev:local
npm run start:dev

docker siempre va a tomar .env


----------------------------------------------------------
cosas por hacer:
1-primero copiar los volumnes de docker y copiarlos en un directorio (listo)
2-generar script para que el directorio se mantenga actualizado a la par de los volumenes(sincronizar) (listo)
3-hacer el servicio de email
4-que el servicios de user le pegue al email services
5-cuando se mande el mail que use rabbit .
6-que auditory consuma esos eventos.
 

------------------------------------------------------------

COMO REUTILIZAR LOS VOLUMENES

(esto para comprimirlos)
Compress-Archive `
  -Path C:\docker-volumes-backup\multiservices `
  -DestinationPath C:\docker-volumes-backup\multiservices-volumes.zip

a) general volumenes de docker
1-docker volume create multiservices_nestjs-net_pgdata
2-docker volume create multiservices_nestjs-net_keycloak_data
3-docker volume create multiservices_nestjs-net_rabbitmq-data
4-docker volume create multiservices_nestjs-net_minio-data

b) deszipear los volumenes 
Expand-Archive multiservices-volumes.zip C:\docker-volumes-backup

c)restaurarlos 
docker run --rm `
  -v multiservices_nestjs-net_pgdata:/volume `
  -v C:\Users\ufarias.ENCODELABS\Desktop\multiservices_nestJS-NET\docker-volumes-backup\pgdata `
  alpine `
  sh -c "cp -a /backup/. /volume/"

  docker run --rm `
  -v multiservices_nestjs-net_rabbitmq-data:/volume `
  -v C:\Users\ufarias.ENCODELABS\Desktop\multiservices_nestJS-NET\docker-volumes-backup\rabbitmq-data `
  alpine `
  sh -c "cp -a /backup/. /volume/"

  docker run --rm `
  -v multiservices_nestjs-net_keycloak_data:/volume `
  -v C:\Users\ufarias.ENCODELABS\Desktop\multiservices_nestJS-NET\docker-volumes-backup\keycloack_data `
  alpine `
  sh -c "cp -a /backup/. /volume/"

  docker run --rm `
  -v multiservices_nestjs-net_minio-data:/volume `
  -v C:\Users\ufarias.ENCODELABS\Desktop\multiservices_nestJS-NET\docker-volumes-backup\minio-data `
  alpine `
  sh -c "cp -a /backup/. /volume/"

  d) una vez tengas todo levantas el ecosistema 
  - docker compose up -d
  - docker compose start (si ya tenes los contenedores)

  tener en cuenta que cada vez que se trabaje con los volumenes hay q actualizarlos antes de terminar
  irse hasta el directorio del script y tirar el comando .\backup-volumes.ps1


que mandar en email send 
 {
  "to": "usuario@example.com",
  "subject": "Bienvenido!",
  "htmlContent": "<h1>Hola Usuario</h1><p>Bienvenido a nuestra plataforma</p>",
  "templateType": "welcome",
  "templateData": {
    "name": "Usuario",
    "email": "usuario@example.com"
  }
}